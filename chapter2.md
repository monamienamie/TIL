# <b>CHAPTER 2. 데이터 준비 </b>
### <b>index</b>
``` 
1. 데이터 타입
    1.1 데이터 베이스 데이터 타입
    1.2 정형 데이터와 반정형 데이터
    1.3 정량 데이터와 정성 데이터
    1.4 퍼스트, 세컨드, 서드 파티 데이터
    1.5 희소 데이터

2. SQL 쿼리 구조
3. 프로파일링: 데이터 분포
4. 프로파일링: 데이터 품질
5. 준비: 데이터 정제
6. 준비: 데이터 셰이핑
7. 결론
```

데이터 랭글링: 원본 데이터를 보다 분석하기 쉬운 형태로 가공하는 과정

 ## <b> 2.1 데이터 타입
###  2.1.1. 데이터 베이스 데이터 타입 </b> <br><br>

주요 데이터 타입: 문자열, 숫자, 논리, 날짜/시간

| 타입 | 이름 | 설명 |
| --- | --- | --- | 
| 문자열 |  CHAR / VARCHAR | 문자열 데이터를 저장,<br>CHAR: 고정 길이 값을 저장 <br> VARCHAR: 지정된 범위 내에서 가변 길이 값을 저장 
|    | TEXT, BLOB | VARCHAR의 범위를 넘어서는 긴 문자열 데이터 저장 <br> 설문 응답 등의 텍스트를 저장
| 숫자 | INT / SMALLINT / BIGINT | 정수 데이터 저장, 데이터 베이스에 따라 SMALLINT 또는 BIGINT를 저장하기도 한다
| | FLOAT / DOUBLE / DECIMAL | 실수 데이터 저장
| 논리 | BOOLEAN | True 또는 False 값을 저장
| 날짜/시간 | DATETIME / TIMESTAMP | 날짜 및 시간 데이터를 저장 <br> 기본 형식: <b>YYYY-MM-DD hh:mi:ss <b>
| | TIME | 시간 데이터를 저장

- DECIMAL은 소수점 위치를 표시
- INT 타입은 DECIMAL보다 메로리를 적게 사용
- 이외에도 JSON이나 지리 타입 등의 데이터 타입이 존재

<br>
<br>

### <b>2.1.2 정형 데이터와 반정형 데이터 </b> 
<br>
<li> 정형 데이터: 각 속성이 열에 저장되고 개체가 행에 저장되는 행렬 형태의 데이터
- 각 필드는 지정된 데이터 타입에 맞는 데이터만 저장할 수 있다.
<br>
<Li> 비정형 데이터: 미리 지정된 구조, 데이터 모델, 데이터 타입이 없음. <br>
e.g. 사진, 이미지, 비디오 오디오 등 <br>
관계형 데이터베이스에 효율적으로 저장하기 어려우며 SQL로 쿼리를 수행하기도 알맞지 않음
<br>
<li> 반정형 데이터: 나름의 구조를 갖춘 비정형 데이터

<br>
<br>

### <b>2.1.3 정량 데이터와 정성 데이터 </b>
<br>
<li> 정량 데이터: 사람, 물건, 이벤트 등을 특정 수치로 정량화한 데이터 -> 숫자 타입의 정보를 저장할 수 있다. <br>
<li> 정성 데이터: 주로 텍스트 형태로 적힌 느낌, 의견, 서술과 같이 명확한 수치로 측정할 수 없는 데이터 
</li>
<br>
<br>

### <b>2.1.4  퍼스트, 세컨드, 서드 파티 데이터 </b>

| 구분 | 설명 | 예시 |
| -- | -- | -- |
| 퍼스트 파티 데이터 | 기관에서 직접 수집한 데이터 | 서버로그, 고객 정보, 거래 데이터 등|
| 세컨드 파티 데이터  | 특정 기관에 서비스를 제공하는 업체에서 수집하는 데이터 | 주로 CRM, 이메일, 자동화 도구 등에 사용되는 SaaS 형태로 제공되는 상품 등 | 
| 서드 파티 데이터 | 어디선가 무료로 얻는 데이터 | 금액을 지불하고 구매하는 데이터, 정부에서 무료로 공개한 데이터 등|
- 서드 파티 데이터는 조직 내부에서 수집하는 데이터가 아니므로 데이터 팀이 데이터 생성 및 수집 과정에 참여해 데이터 형식 수집 주기, 품질 등을 조정할 수 없음


<br>
<br>

### <b>2.1.5 희소 데이터</b>
- 희소 데이터 saparse data: 빈 값이나 중요하지 않은 정보가 많이 포함돼 크기에 비해 의미 있는 정보가 적은 데이터 셋
- 가공 방법: 
    1. 자주 발생하지 않는 이벤트를 더 자주 발생하는 이벤트의 하위로 묶거나
    2. 희소 데이터를 삭제하거나
    3. 희소 데이터가 많이 발생하는 시간대 등을 분석하여 분석에서 제외하는 방법 등이 있다.

## <b> 2.2 SQL 쿼리 구조 </b>
- SELECT : 쿼리를 통해 어느 절을 가져올 것인지 결정
- FROM : SELECT 절에서 언급한 컬럼을 어떤 테이블에서 가져올 것인지 결정, 여러 테이블을 참조하기 위한 JOIN 을 수행
    - INNER JOIN: 두 테이블에서 상응하는 모든 레코드를 가져옴
    - LEFT JOIN: 첫 번째 테이블의 레코드를 모두 가져오고, 두 번째 테이블에서는 첫 번째 테이블과 상응하는 레코드만 가져옴
    - FULL OUTER JOIN:  두 테이블에서 조건에 맞는 레코드를 모두 가져옴
    - 카티션 JOIN: 명시된 조건으로 첫 번째 테이블의 각 레코드가 두 번째 테이블의 여러 레코드와 일치하는 경우에 발생 -> 의도적으로 시계열 분석에서 날짜 데이터를 채워 넣는 등 <b>특수한 목적이 있을 때가 아니면 사용하지 않는다.</b>
- WHERE: SELECT 절을 통해 가져올 컬럼의 조건을 설정
- GROUP BY: 주로 SELECT 절에서 특정 필드를 그룹화하고 그룹별 집계를 수행하기 위해 사용
    - 집계를 수행할 필드와 집계에 사용되지 않는 필드가 최소한 하나씩 있어야 합니다.

<br>
<b> 데이터 베이스를 죽이지 않는 방법: LIMIT와 샘플링 </b> 

``` 
데이터 베이스에서 불러올 정보가 너무 많은 경우, 오류가 나거나 DB가 죽어버릴 수 있다. 이를 방지하기 위해서는 프로파일링, LIMIT 또는 샘플링을 이용해 반환할 쿼리의 수를 제한하는 방법을 사용하는 것이 좋다.


1. LIMIT
LIMIT 절은 쿼리의 맨 마지막에서 제한할 레코드의 개수를 제한할 수 있다.
SELECT col1, col2
FROM table
LIMIT 100 -- 100개 행으로 출력 레코드 수 제한

2. 샘플링
- 나눗셈의 나머지 (MOD) 함수를 이용한 샘플링
- WHERE절의 조건을 이용한 (e.g. 필드의 마지막 글자를 활용 등)
```


